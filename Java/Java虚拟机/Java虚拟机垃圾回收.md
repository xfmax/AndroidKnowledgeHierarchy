## 一.Java虚拟机结构
首先，我们要明白Java虚拟机执行的class文件，也就是我们说的字节码，它会将字节码翻译成机器码，供计算机执行。

让我们来了解一下class文件，class文件是由Java编译器根据java文件生成的，其中包含魔术（0xCAFEBABY）、常量池、接口表、字段表、方法表等。

#### 类的生命周期：
1.加载：根据名字找到二进制字节流，将这个二进制字节流所代表的静态储存结构变为运行时的数据结构，在内存中生成一个代表这个Class的对象，作为方法区这个类的各种数据的访问入口。
2.链接：

    验证：确保导入类型的正确性。
    准备：将静态变量分配内存空间，赋默认值。
    解析：将符号引用替换为直接引用。
3.初始化：将类变量初始化为正确的初始值。

#### 类加载子系统
类加载子系统的工作是类生命周期中加载的时候执行根据名字找到对应的二进制流，并创建class对象，作为方法区该类的访问入口。

其中分为三种加载器：
1.BootStrapClassLoader 加载Java自身的api的，例如java.lang、java.util等这些系统类。
2.ExtensionsClassLoader 加载$JAVA_HOME/jre/lib/ext文件。
3.ApplicationClassLoader 加载当前应用的ClassPath目录。

#### 运行时数据区域
1.程序计数器：线程私有，用来确定下一条指令的地址。
2.Java虚拟机栈：包括局部变量、参数、返回值以及运算的中间结果等。
3.本地方法栈：同Java虚拟机栈类似，只不过支持的Native方法。
4.Java堆：所有线程共享的运行时内存区域。
5.方法区（运行时常量池）：共享的运行时内存区域，用来存储已经被Java虚拟机加载的类的结构信息，包括运行时常量池，字段和方法信息、静态变量等数据，Class文件不仅包含类的版本、接口、字段和方法等信息。

## 二.对象的创建
1.判断对相对应的类是否加载、链接和初始化。
2.为对象分配内存。
3.处理并发安全。
4.初始化分配到的内存空间。
5.设置对象的对象头。

## 三.垃圾回收机制
标记算法：引用计数算法+根搜索算法
引用计数法的缺点是不能解决互相引用的问题，所以被抛弃。

根搜索算法：从一个GC ROOTS开始，根据引用关系依次寻找，如果有引用不在这条链条上的时候，就可以被GC标记为可清除。

**可以作为GC ROOTS的对象有：**

    1.java栈中引用的对象。
    2.本地方法栈中JNI引用的对象。

    3.方法区中运行时常量池引用的对象。
    4.方法区中的静态属性引用的对象。

    5.运行中的线程。
    6.由引导类加载器加载的对象。
    7.GC控制的对象。

垃圾收集算法：标记-清除算法 标记-压缩算法 复制算法。

标记清除算法：将内存上的需要清除的位置进行标记并清除，缺点是内存碎片化。

标记压缩算法：在标记清除的基础上，对已经清除的空间已经整理压缩，使之后的内存分配在物理层面上保持连续状态。

复制算法：将内存空间分成两部分，当GC时，将GC后留下的对象放到另一个内存空间中。优点是不用考虑分配压缩等问题，缺点是有一半的内存空间是浪费的。

#### 分代收集算法：

根据对象生命周期的不同，将虚拟机堆划分成不同的区域，也就是分代的概念。

jvm将分代的区域分为 新生代 老年代，其中新生代分为eden、from survivor、to survivor，因为Eden中的对象存活时间较短，所以虚拟机分配的空间也不是平均分配，HotSpot默认的Eden和两个survivor空间的比值为8:1。

分代是为了解决对象生命周期不同的问题，所以在每个不同的分代区域会根据这个区域的特点执行适宜的垃圾回收算法。

垃圾回收的类型也有两种，根据分代不同而不同：

    1.Minor Collection:新生代垃圾回收。
    2.Full Collection:老年代垃圾回收，通常伴随一次Minor Collection，它的收集频率较低，时间较长。