## 原理
首先，快速排序是一种非常高效的排序算法，应用于很多实际的生产环境中，那么我们需要来先了解一下快排的原理。

它本身的原理其实很简单，叫做分治，也就是分而治之的意思，再简单点说，就是把一个待排序的序列按照某些属性分类。

针对与一个整型数组来说，这个属性就是大小，因为整型数字只有大小这一个属性，也就是说给定一个**标准值**，比这个标注值大的分为一堆，比这个标准值小的分为一堆，然后在这两堆再分别如上的操作，也就是递归操作，最后得到一个有序的整型序列，怎么样，原理不难吧，可是写起来，还真是有点难度的，接下来，我们画一个张图来理解。

![quicksort](https://github.com/xfmax/AndroidKnowledgeHierarchy/blob/master/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/image/sorting_quicksort_anim.gif)


可以看到非常直观的程序执行时的动画，接着，我们在看通过代码的方式看看如何实现，请注意看其中的注释。

```java
public class QuickSort{
    public void quickSort(int[] arr,int lo,int hi){
        if(lo >= hi) return;
        int j = partition(arr,lo,hi);
        quickSort(arr,lo,j-1);
        quickSort(arr,j+1,hi);
    }

    public int partition(int[] arr,int lo ,int hi){
        int i = lo;
        int j = hi+1;//这里加1，是为了后面--j操作，这样可以保证第一次操作的还是hi。
        int key = arr[lo];//这表明选定了lo的值作为上文中讲述的标准值

        //跳出循环的条件是从序列左边开始搜索的i到达了hi位置，或者从序列右边搜索的j到达了lo位置。
        while(true){
            while(arr[++i]<key){//选定了lo作为标准值后，第一次对比就要从i+1开始，相当于跨过了i，这下就明白了为什么在定义的时候hi要加1，但是lo没有加1
                if(i == hi)break;
            }
            while(arr[--j]>key){//为了保持和上面的while语句相似的句法设置，所以在定义的时候给hi加了1，这里再用--，保证第一次对比是从hi开始的
                if(j == lo)break;
            }

            //如果i >= j,说明排序就结束了
            if(i >= j)break;

            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
       
       //将标准值与j互换位置，因为以j为界限，左边都小于arr[j]，右边都大于arr[j]了，这样交换之后，就完成了一次partition过程
        int tmp = arr[lo];
        arr[lo] = arr[j];
        arr[j] = tmp;
        return j;
    }

}
```
这种方式也是原地切分的方式，时间复杂度为O(NlgN)，空间复杂度O(1gN)