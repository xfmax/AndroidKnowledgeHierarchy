### task1：二叉树的遍历
### task2：求二叉树的深度

首先，我们先来了解一下什么是二叉树：

由于链表擅长增加和擅长操作，数组擅长查找操作，那么我们就想有没有一种数据结构是兼具这两个优点的呢，答案就是树形结构，那么二叉树顾名思义是一个最多每个结点可以有两个叉的树，这是一种一对多的线性结构。

#### 树的属性：

结点的度：结点拥有的子树的个数。
叶结点：度为0的结点。
分支结点：度不为0的结点。
孩子：结点的子树的根，反过来这个称为孩子的双亲。
兄弟：同一个双亲的孩子们。
森林：m(>=0)颗互不相交的树的集合，每个结点的子树的集合就是一个森林。

### 树的存储结构

无论是顺序存储还是链式存储都不能满足树的实现，那么就需要这两种存储方式的结合使用。
这样延伸出了三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。

#### 双亲表示法：除了根结点，其他结点都有双亲，每个结点都有数据以及双亲在数组的下标，缺点是如果你要想查找某个孩子结点，你得遍历整个结构，当然你还可以追加域，例如长子域，兄弟域等。

#### 孩子表示法：

    每个结点有多个指针域，其中每个指针指向一颗子树的根结点。由于树的每个结点的度的不同，有两种方案设计来解决：

    1.结点数据data+指针域+指针域+...+指针域 ，根据结点的度来确定指针域的个数，每个结点都是使用树的度的长度来存储，也就是左右结点的度的最大值，这个长度来储存，缺点很明显，有点浪费空间。
    2.在1的基础上追加一个指针域的个数，也就是该结点的度，这样解决了浪费空间的问题，可是每个结点的长度都不同，计算起来也会带来损耗。

所以孩子表示法就是，结点数据存储在数据里，同时每个结点的孩子以一条单链表的形式进行存储。

这种表示法需要两种数据结构，一种是该结点和其第一个孩子结点的指针，另一种是当前孩子结点和下一个孩子结点。这种表示法就是查找双亲比较麻烦，那么有没有一种一举两得的好方法呢：

将第一种数据结构追加一个双亲的指针，这种方法也被称为双亲孩子表示法。

#### 孩子兄弟表示法

结点data+第一个孩子+右兄弟，如果遍历双亲麻烦，还可以在此数据结构中追加双亲的指针，这样我们就构建了一颗二叉树。

#### 二叉树：n(n>=0)个结点的有限集合，该集合或者为空集，或者有一个根结点和两颗互不想交的、分别称为左子树和右子树的二叉树组成。

特点：

    * 每个结点最多有两颗子树，所以最大度不超过2。
    * 左子树和右子树是有顺序的，次序不能任意颠倒。
    * 即使某个结点只有一个子树，也要区分是左子树还是右子书。

斜树：所有结点都往左斜的叫左斜树，所有结点都往右斜的叫右斜树。

满二叉树：所有结点都有左子树和右子树，并且叶子结点都在一层。

完全二叉树：如果1<=i<=n,如果i的结点与同样深度的满二叉树中结点位置完全相同。

完全二叉树特性：

    1.叶子结点只能出现在最下二层
    2.最下层的叶子一定集中在左部连续位置。
    3.倒数第二层，若有叶子结点，一定集中在右部连续。
    4.结点度为1，则该结点只有左孩子，不存在只有右孩子的情况。
    5.同样结点数的二叉树，完全二叉树深度最小。


二叉树的性质：

性质1：在二叉树的第i层上至多有2^(i-1)个结点 （i>=1）
性质2：深度为k的二叉树至多有2^k-1个结点（k>=1）
性质3：对任何一颗二叉树T，如果其终端结点数为p，度为2的结点数为q，则p = q + 1


### 二叉树的存储结构

我们要知道二叉树的存储结构，才能进而得知如何来查找或者增删数据。

#### 顺序存储

按照序号依次存储，如果遇到了空结点，就以^来表示。

但是如果是一个深度为k的左斜树或者右斜树，那么一共要分配2^k-1个存储单元，可是只能用上k个存储单元，这会造成浪费。


#### 二叉链表

结点的数据结构为一个data域，左孩子结点域，右孩子结点域。

如果还需要一个指向其双亲的域，那么就会形成三叉链表。


task1：重点要来了，二叉树的遍历：

对于二叉树的遍历，**次序**和**访问**是非常重要的概念。

因为树有很多岔路，所以在遍历的时候有很多选择，也就衍生出很多种的遍历方法：

1.前序遍历

    除非二叉树为空，否则先访问根结点--->左子树--->右子树，遵循中左右的顺序。

2.中序遍历

    除非二叉树为空，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，也就是从叶子结点开始遍历，然后是访问根结点，最后中序遍历右子树，基本遵循左中右的顺序。

3.后序遍历

    除非二叉树为空，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点，遵循左右中，**最后根结点**。

4.层序遍历

    除非二叉树为空，否则从树的第一层开始访问，从上而下逐层访问，在同一层，按照从左到右的顺序访问。

接着上代码：

```java
 //先序遍历
    private static void preorderTraversal(BiTree tree){
        if (tree == null) {
            return;
        }
        System.out.println(tree.getValue());
        preorderTraversal(tree.getLeftChild());
        preorderTraversal(tree.getRightChild());
    }
```
```java
 //中序遍历
    private static void inOrderTraversal(BiTree biTree) {
        if (biTree == null) {
            return;
        }
        inOrderTraversal(biTree.getLeftChild());
        System.out.println(biTree.getValue());
        inOrderTraversal(biTree.getRightChild());

    }
```
```java
 //后续遍历
    private static void postTraversal(BiTree biTree){
        if (biTree == null) {
            return ;
        }

        postTraversal(biTree.getLeftChild());
        postTraversal(biTree.getRightChild());
        System.out.println(biTree.getValue());
    }
```

所以，可以看出二叉树的精要是**递归**，从它的定义和它的遍历都是和递归有关联，如果在面试中考察二叉树，也就是考察递归，切记切记。

#### task2:求一个二叉树的深度

```java
private int treeDepth(TreeNode node){
    if(node == null){
        return 0;
    }
    int left = treeDepth(node.left);
    int right = treeDepth(node.right);
    return left > right ? (left + 1):(right + 1);
}
```
注意，这里使用的递归是有返回值的，这就更加需要你了解递归的流程，了解递归的函数在栈中的存储格式，进栈出栈等，这相当于没递归一次就为返回值 +1 ，最后返回加了几次，就知道深度了，这种思想就是递归的核心，有一种层层递进，再层层回退的感觉，经过这一来一回，就将深度统计出来了。