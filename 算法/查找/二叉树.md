### task1：二叉树的遍历
### task2：求二叉树的深度

首先，我们先来了解一下什么是二叉树：

由于链表擅长增加和擅长操作，数组擅长查找操作，那么我们就想有没有一种数据结构是兼具这两个优点的呢，答案就是树形结构，那么二叉树顾名思义是一个最多每个结点可以有两个叉的树，这是一种一对多的线性结构。

#### 树的属性：

结点的度：结点拥有的子树的个数。
叶结点：度为0的结点。
分支结点：度不为0的结点。
孩子：结点的子树的根，反过来这个称为孩子的双亲。
兄弟：同一个双亲的孩子们。
森林：m(>=0)颗互不相交的树的集合，每个结点的子树的集合就是一个森林。

### 树的存储结构

无论是顺序存储还是链式存储都不能满足树的实现，那么就需要这两种存储方式的结合使用。
这样延伸出了三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。

#### 双亲表示法：除了根结点，其他结点都有双亲，每个结点都有数据以及双亲在数组的下标，缺点是如果你要想查找某个孩子结点，你得遍历整个结构，当然你还可以追加域，例如长子域，兄弟域等。

#### 孩子表示法：

    每个结点有多个指针域，其中每个指针指向一颗子树的根结点。由于树的每个结点的度的不同，有两种方案设计来解决：

    1.结点数据data+指针域+指针域+...+指针域 ，根据结点的度来确定指针域的个数，每个结点都是使用树的度的长度来存储，也就是左右结点的度的最大值，这个长度来储存，缺点很明显，有点浪费空间。
    2.在1的基础上追加一个指针域的个数，也就是该结点的度，这样解决了浪费空间的问题，可是每个结点的长度都不同，计算起来也会带来损耗。

所以孩子表示法就是，结点数据存储在数据里，同时每个结点的孩子以一条单链表的形式进行存储。

这种表示法需要两种数据结构，一种是该结点和其第一个孩子结点的指针，另一种是当前孩子结点和下一个孩子结点。这种表示法就是查找双亲比较麻烦，那么有没有一种一举两得的好方法呢：

将第一种数据结构追加一个双亲的指针，这种方法也被称为双亲孩子表示法。

#### 孩子兄弟表示法

结点data+第一个孩子+右兄弟，如果遍历双亲麻烦，还可以在此数据结构中追加双亲的指针，这样我们就构建了一颗二叉树。

二叉树：n(n>=0)个结点的有限集合，该集合或者为空集，或者有一个根结点和两颗互不想交的、分别称为左子树和右子树的二叉树组成。

特点：

    * 每个结点最多有两颗子树，所以最大度不超过2。
    * 左子树和右子树是有顺序的，次序不能任意颠倒。
    * 即使某个结点只有一个子树，也要区分是左子树还是右子书。

斜树：所有结点都往左斜的叫左斜树，所有结点都往右斜的叫右斜树。

满二叉树：所有结点都有左子树和右子树，并且叶子结点都在一层。

完全二叉树：如果1<=i<=n,如果i的结点与同样深度的满二叉树中结点位置完全相同。

完全二叉树特性：

    1.叶子结点只能出现在最下二层
    2.最下层的叶子一定集中在左部连续位置。
    3.倒数第二层，若有叶子结点，一定集中在右部连续。
    4.结点度为1，则该结点只有左孩子，不存在只有右孩子的情况。
    5.同样结点数的二叉树，完全二叉树深度最小。


二叉树的性质：

性质1：在二叉树的第i层上至多有2^(i-1)个结点 （i>=1）
性质2：深度为k的二叉树至多有2^k-1个结点（k>=1）
性质3：对任何一颗二叉树T，如果其终端结点数为p，度为2的结点数为q，则p = q + 1